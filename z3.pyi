from fractions import Fraction
from .z3core import *
from .z3types import *
from .z3consts import *
from .z3printer import *
from . import z3core as z3core
from typing import Any, Optional
import typing

asBoolRef = typing.Union[BoolRef, bool]
asExprRef = typing.Union[ExprRef, int, bool, float, str]
asArithRef = typing.Union[ArithRef, int, float, str]

Z3_DEBUG: bool = __debug__

def z3_debug() -> bool: ...
def enable_trace(msg: str) -> None: ...
def disable_trace(msg: str) -> None: ...
def get_version_string() -> str: ...
def get_version() -> tuple[int, int, int, int]: ...
def get_full_version(): ...
def open_log(fname: str) -> None: ...
def append_log(s: str) -> None: ...
def to_symbol(s: int | str, ctx: typing.Optional[Context] = ...): ...
def z3_error_handler(c, e) -> None: ...

class Context:
    ctx: ContextObj
    eh: typing.Callable
    def __init__(self, *args, **kws) -> None: ...
    def __del__(self) -> None: ...
    def ref(self) -> ContextObj: ...
    def interrupt(self) -> None: ...

TT = typing.TypeVar("TT")

def main_ctx() -> Context: ...
@typing.overload
def get_ctx(ctx: None) -> Context: ...
@typing.overload
def get_ctx(ctx: TT) -> TT: ...
def set_param(*args, **kws) -> None: ...
def reset_params() -> None: ...
def set_option(*args, **kws) -> None: ...
def get_param(name: str) -> str: ...

class Z3PPObject:
    def use_pp(self) -> bool: ...

class AstRef(Z3PPObject):
    ast: Ast
    ctx: Context
    def __init__(self, ast: Ast, ctx: typing.Optional[Context] = ...) -> None: ...
    def __del__(self) -> None: ...
    def __deepcopy__(self, memo: dict = ...) -> AstRef: ...
    def __eq__(self, other: AstRef) -> bool: ...
    def __hash__(self) -> int: ...
    def __nonzero__(self) -> bool: ...
    def __bool__(self) -> bool: ...
    def sexpr(self) -> str: ...
    def as_ast(self) -> Ast: ...
    def get_id(self) -> int: ...
    def ctx_ref(self) -> ContextObj: ...
    def eq(self, other: AstRef) -> bool: ...
    def translate(self, target: Context) -> AstRef: ...
    def __copy__(self) -> AstRef: ...
    def hash(self) -> int: ...

def is_ast(a: Any) -> bool: ...
def eq(a: AstRef, b: AstRef) -> bool: ...

class SortRef(AstRef):
    def as_ast(self) -> Ast: ...
    def get_id(self) -> int: ...
    def kind(self): ...
    def subsort(self, other: SortRef) -> bool: ...
    def cast(self, val: Any) -> Any: ...
    def name(self) -> str: ...
    def __eq__(self, other: Optional[SortRef]) -> bool: ...
    def __ne__(self, other: Optional[SortRef]) -> bool: ...
    def __hash__(self) -> int: ...

def is_sort(s: Any) -> bool: ...
def DeclareSort(name: str, ctx: Optional[Context] = ...) -> SortRef: ...

class FuncDeclRef(AstRef):
    def as_ast(self) -> Ast: ...
    def get_id(self) -> int: ...
    def as_func_decl(self) -> Ast: ...
    def name(self) -> str: ...
    def arity(self) -> int: ...
    def domain(self, i: int) -> SortRef: ...
    def range(self) -> SortRef: ...
    def kind(self) -> int: ...
    def params(self) -> list[Any]: ...
    @typing.overload
    def __call__(self, *args: asExprRef) -> ExprRef: ...
    @typing.overload
    def __call__(self, args: typing.Sequence[asExprRef]) -> ExprRef: ...

def is_func_decl(a: AstRef) -> bool: ...
def Function(name: str, *sig: SortRef) -> FuncDeclRef: ...
def FreshFunction(*sig: SortRef) -> FuncDeclRef: ...
def RecFunction(name: str, *sig: SortRef) -> FuncDeclRef: ...
def RecAddDefinition(
    f: FuncDeclRef, args: ExprRef | typing.Sequence[ExprRef], body: ExprRef
) -> None: ...

class ExprRef(AstRef):
    def as_ast(self) -> Ast: ...
    def get_id(self) -> int: ...
    def sort(self) -> SortRef: ...
    def sort_kind(self) -> int: ...
    def __eq__(self, other: asExprRef) -> BoolRef: ...
    def __hash__(self) -> int: ...
    def __ne__(self, other: asExprRef) -> BoolRef: ...
    def params(self) -> list[Any]: ...
    def decl(self) -> FuncDeclRef: ...
    def num_args(self) -> int: ...
    def arg(self, idx: int) -> ExprRef: ...
    def children(self) -> list[ExprRef]: ...

def is_expr(a: AstRef) -> bool: ...
def is_app(a: AstRef) -> bool: ...
def is_const(a: AstRef) -> bool: ...
def is_var(a: AstRef) -> bool: ...
def get_var_index(a) -> int: ...
def is_app_of(a: AstRef, k: int) -> bool: ...
@typing.overload
def If(
    a: Probe, b: asBoolRef | Tactic, c: asBoolRef | Tactic, ctx: Optional[Context] = ...
) -> Probe: ...
@typing.overload
def If(
    a: asBoolRef | Probe, b: Tactic, c: asBoolRef | Tactic, ctx: Optional[Context] = ...
) -> Probe: ...
@typing.overload
def If(
    a: asBoolRef | Probe, b: asBoolRef | Tactic, c: Tactic, ctx: Optional[Context] = ...
) -> Probe: ...
@typing.overload
def If(
    a: asBoolRef, b: asExprRef, c: asExprRef, ctx: Optional[Context] = ...
) -> asExprRef: ...
def Distinct(*args: asExprRef) -> BoolRef: ...
def Const(name: str, sort: SortRef) -> ExprRef: ...
def Consts(names: str | typing.Iterable[str], sort: SortRef) -> ExprRef: ...
def FreshConst(sort: SortRef, prefix: str = ...) -> ExprRef: ...
def Var(idx: int, s: SortRef) -> ExprRef: ...
def RealVar(idx: int, ctx: Optional[Context] = ...) -> ExprRef: ...
def RealVarVector(n: int, ctx: Optional[Context] = ...) -> list[ExprRef]: ...

class BoolSortRef(SortRef):
    def cast(self, val: bool | ExprRef) -> BoolRef: ...
    def subsort(self, other: SortRef) -> bool: ...
    def is_int(self) -> typing.Literal[True]: ...
    def is_bool(self) -> typing.Literal[True]: ...

class BoolRef(ExprRef):
    def sort(self) -> BoolSortRef: ...
    def __rmul__(self, other: asExprRef) -> ExprRef | int: ...
    def __mul__(self, other: asExprRef) -> ExprRef | int: ...

def is_bool(a: AstRef) -> bool: ...
def is_true(a: AstRef) -> bool: ...
def is_false(a: AstRef) -> bool: ...
def is_and(a: AstRef) -> bool: ...
def is_or(a: AstRef) -> bool: ...
def is_implies(a: AstRef) -> bool: ...
def is_not(a: AstRef) -> bool: ...
def is_eq(a: AstRef) -> bool: ...
def is_distinct(a: AstRef) -> bool: ...
def BoolSort(ctx: Optional[Context] = ...) -> BoolSortRef: ...
def BoolVal(val: bool, ctx: Optional[Context] = ...) -> BoolRef: ...
def Bool(name: str, ctx: Optional[Context] = ...) -> BoolRef: ...
def Bools(
    names: str | typing.Iterable[str], ctx: Optional[Context] = ...
) -> typing.Sequence[BoolRef]: ...
def BoolVector(
    prefix: str, sz: int, ctx: Optional[Context] = ...
) -> typing.Sequence[BoolRef]: ...
def FreshBool(prefix: str = ..., ctx: Optional[Context] = ...) -> BoolRef: ...
def Implies(a: asBoolRef, b: asBoolRef, ctx: Optional[Context] = ...) -> BoolRef: ...
def Xor(a: asBoolRef, b: asBoolRef, ctx: Optional[Context] = ...) -> BoolRef: ...
@typing.overload
def Not(a: asBoolRef, ctx: Optional[Context] = ...) -> BoolRef: ...
@typing.overload
def Not(a: Probe, ctx: Optional[Context] = ...) -> Probe: ...
def mk_not(a: ExprRef) -> asBoolRef: ...
@typing.overload
def And(*args: Probe) -> Probe: ...
@typing.overload
def And(*args: Probe, ctx: Context) -> Probe: ...
@typing.overload
def And(*args: asBoolRef) -> BoolRef: ...
@typing.overload
def And(*args: asBoolRef, ctx: Context) -> BoolRef: ...
@typing.overload
def And(vec: AstVector, /) -> BoolRef: ...
@typing.overload
def And(vec: AstVector, ctx: Context, /) -> BoolRef: ...
@typing.overload
def Or(*args: Probe) -> Probe: ...
@typing.overload
def Or(*args: Probe, ctx: Context) -> Probe: ...
@typing.overload
def Or(*args: asBoolRef) -> BoolRef: ...
@typing.overload
def Or(*args: asBoolRef, ctx: Context) -> BoolRef: ...
@typing.overload
def Or(vec: AstVector, /) -> BoolRef: ...
@typing.overload
def Or(vec: AstVector, ctx: Context, /) -> BoolRef: ...

class PatternRef(ExprRef):
    def as_ast(self) -> Ast: ...
    def get_id(self) -> int: ...

def is_pattern(a: AstRef) -> bool: ...
def MultiPattern(*args: ExprRef) -> PatternRef: ...

class QuantifierRef(BoolRef):
    def as_ast(self) -> Ast: ...
    def get_id(self) -> int: ...
    def sort(self) -> SortRef: ...
    def is_forall(self) -> bool: ...
    def is_exists(self) -> bool: ...
    def is_lambda(self) -> bool: ...
    def __getitem__(self, arg: asExprRef) -> ExprRef: ...
    def weight(self) -> int: ...
    def num_patterns(self) -> int: ...
    def pattern(self, idx: int) -> PatternRef: ...
    def num_no_patterns(self): ...
    def no_pattern(self, idx: int): ...
    def body(self) -> ExprRef: ...
    def num_vars(self) -> int: ...
    def var_name(self, idx: int) -> str: ...
    def var_sort(self, idx: int) -> SortRef: ...
    def children(self) -> typing.Sequence: ...

def is_quantifier(a: AstRef) -> bool: ...
def ForAll(
    vs: typing.Sequence[ExprRef] | ExprRef,
    body: ExprRef,
    weight: int = ...,
    qid: str = ...,
    skid: str = ...,
    patterns: typing.Iterable[PatternRef | ExprRef] = ...,
    no_patterns: typing.Iterable[ExprRef] = ...,
) -> QuantifierRef: ...
def Exists(
    vs: typing.Sequence[ExprRef] | ExprRef,
    body: ExprRef,
    weight: int = ...,
    qid: str = ...,
    skid: str = ...,
    patterns: typing.Iterable[PatternRef | ExprRef] = ...,
    no_patterns: typing.Iterable[ExprRef] = ...,
) -> QuantifierRef: ...
def Lambda(vs: typing.Sequence[ExprRef] | ExprRef, body: ExprRef) -> QuantifierRef: ...

class ArithSortRef(SortRef):
    def is_real(self) -> bool: ...
    def is_int(self) -> bool: ...
    def subsort(self, other: SortRef) -> bool: ...
    def cast(self, val: asArithRef) -> ArithRef: ...

def is_arith_sort(s: SortRef) -> bool: ...

class ArithRef(ExprRef):
    def sort(self) -> ArithSortRef: ...
    def is_int(self) -> bool: ...
    def is_real(self) -> bool: ...
    def __add__(self, other: asArithRef) -> ArithRef: ...
    def __radd__(self, other: asArithRef) -> ArithRef: ...
    def __mul__(self, other: asArithRef) -> ArithRef: ...
    def __rmul__(self, other: asArithRef) -> ArithRef: ...
    def __sub__(self, other: asArithRef) -> ArithRef: ...
    def __rsub__(self, other: asArithRef) -> ArithRef: ...
    def __pow__(self, other: asArithRef) -> ArithRef: ...
    def __rpow__(self, other: asArithRef) -> ArithRef: ...
    def __div__(self, other: asArithRef) -> ArithRef: ...
    def __truediv__(self, other: asArithRef) -> ArithRef: ...
    def __rdiv__(self, other: asArithRef) -> ArithRef: ...
    def __rtruediv__(self, other: asArithRef) -> ArithRef: ...
    def __mod__(self, other: asArithRef) -> ArithRef: ...
    def __rmod__(self, other: asArithRef) -> ArithRef: ...
    def __neg__(self) -> ArithRef: ...
    def __pos__(self) -> ArithRef: ...
    def __le__(self, other: asArithRef) -> BoolRef: ...
    def __lt__(self, other: asArithRef) -> BoolRef: ...
    def __gt__(self, other: asArithRef) -> BoolRef: ...
    def __ge__(self, other: asArithRef) -> BoolRef: ...

def is_arith(a: AstRef) -> bool: ...
def is_int(a: AstRef) -> bool: ...
def is_real(a: AstRef) -> bool: ...
def is_int_value(a: AstRef) -> bool: ...
def is_rational_value(a: AstRef) -> bool: ...
def is_algebraic_value(a: AstRef) -> bool: ...
def is_add(a: AstRef) -> bool: ...
def is_mul(a: AstRef) -> bool: ...
def is_sub(a: AstRef) -> bool: ...
def is_div(a: AstRef) -> bool: ...
def is_idiv(a: AstRef) -> bool: ...
def is_mod(a: AstRef) -> bool: ...
def is_le(a: AstRef) -> bool: ...
def is_lt(a: AstRef) -> bool: ...
def is_ge(a: AstRef) -> bool: ...
def is_gt(a: AstRef) -> bool: ...
def is_is_int(a: AstRef) -> bool: ...
def is_to_real(a: AstRef) -> bool: ...
def is_to_int(a: AstRef) -> bool: ...

class IntNumRef(ArithRef):
    def as_long(self) -> int: ...
    def as_string(self) -> str: ...
    def as_binary_string(self) -> bytes: ...

class RatNumRef(ArithRef):
    def numerator(self) -> IntNumRef: ...
    def denominator(self) -> IntNumRef: ...
    def numerator_as_long(self) -> int: ...
    def denominator_as_long(self) -> int: ...
    def is_int(self) -> typing.Literal[False]: ...
    def is_real(self) -> typing.Literal[True]: ...
    def is_int_value(self) -> bool: ...
    def as_long(self) -> int: ...
    def as_decimal(self, prec: int) -> str: ...
    def as_string(self) -> str: ...
    def as_fraction(self) -> Fraction: ...

class AlgebraicNumRef(ArithRef):
    def approx(self, precision: int = ...) -> RatNumRef: ...
    def as_decimal(self, prec: int) -> str: ...
    def poly(self) -> AstVector: ...
    def index(self) -> Any: ...

def IntSort(ctx: Optional[Context] = ...) -> ArithSortRef: ...
def RealSort(ctx: Optional[Context] = ...) -> ArithSortRef: ...
def IntVal(val: int, ctx: Optional[Context] = ...) -> IntNumRef: ...
def RealVal(val: asArithRef, ctx: Optional[Context] = ...) -> RatNumRef: ...
def RatVal(a: int | str, b: int | str, ctx: Optional[Context] = ...) -> RatNumRef: ...
def Q(a: int | str, b: int | str, ctx: Optional[Context] = ...) -> RatNumRef: ...
def Int(name: str, ctx: Optional[Context] = ...) -> ArithRef: ...
def Ints(
    names: str | typing.Iterable[str], ctx: Optional[Context] = ...
) -> list[ArithRef]: ...
def IntVector(prefix: str, sz: int, ctx: Optional[Context] = ...) -> list[ArithRef]: ...
def FreshInt(prefix: str = ..., ctx: Optional[Context] = ...) -> ArithRef: ...
def Real(name: str, ctx: Optional[Context] = ...) -> ArithRef: ...
def Reals(
    names: str | typing.Iterable[str], ctx: Optional[Context] = ...
) -> list[ArithRef]: ...
def RealVector(
    prefix: str, sz: int, ctx: Optional[Context] = ...
) -> list[ArithRef]: ...
def FreshReal(prefix: str = ..., ctx: Optional[Context] = ...) -> ArithRef: ...
def ToReal(a: ExprRef) -> ArithRef: ...
def ToInt(a: ExprRef) -> ArithRef: ...
def IsInt(a: AstRef) -> BoolRef: ...
def Sqrt(a: asArithRef, ctx: Optional[Context] = ...) -> RatNumRef: ...
def Cbrt(a: asArithRef, ctx: Optional[Context] = ...) -> RatNumRef: ...

class BitVecSortRef(SortRef):
    def size(self) -> int: ...
    def subsort(self, other: SortRef) -> bool: ...
    def cast(self, val) -> BitVecRef: ...

def is_bv_sort(s: SortRef) -> bool: ...

class BitVecRef(ExprRef):
    def sort(self) -> BitVecSortRef: ...
    def size(self) -> int: ...
    def __add__(self, other: asArithRef) -> BitVecRef: ...
    def __radd__(self, other: asArithRef) -> BitVecRef: ...
    def __mul__(self, other: asArithRef) -> BitVecRef: ...
    def __rmul__(self, other: asArithRef) -> BitVecRef: ...
    def __sub__(self, other: asArithRef) -> BitVecRef: ...
    def __rsub__(self, other: asArithRef) -> BitVecRef: ...
    def __or__(self, other: asArithRef) -> BitVecRef: ...
    def __ror__(self, other: asArithRef) -> BitVecRef: ...
    def __and__(self, other: asArithRef) -> BitVecRef: ...
    def __rand__(self, other: asArithRef) -> BitVecRef: ...
    def __xor__(self, other: asArithRef) -> BitVecRef: ...
    def __rxor__(self, other: asArithRef) -> BitVecRef: ...
    def __pos__(self) -> BitVecRef: ...
    def __neg__(self) -> BitVecRef: ...
    def __invert__(self) -> BitVecRef: ...
    def __div__(self, other: asArithRef) -> BitVecRef: ...
    def __truediv__(self, other: asArithRef) -> BitVecRef: ...
    def __rdiv__(self, other: asArithRef) -> BitVecRef: ...
    def __rtruediv__(self, other: asArithRef) -> BitVecRef: ...
    def __mod__(self, other: asArithRef) -> BitVecRef: ...
    def __rmod__(self, other: asArithRef) -> BitVecRef: ...
    def __le__(self, other: asArithRef) -> BoolRef: ...
    def __lt__(self, other: asArithRef) -> BoolRef: ...
    def __gt__(self, other: asArithRef) -> BoolRef: ...
    def __ge__(self, other: asArithRef) -> BoolRef: ...
    def __rshift__(self, other: asArithRef) -> BitVecRef: ...
    def __lshift__(self, other: asArithRef) -> BitVecRef: ...
    def __rrshift__(self, other: asArithRef) -> BitVecRef: ...
    def __rlshift__(self, other: asArithRef) -> BitVecRef: ...

class BitVecNumRef(BitVecRef):
    def as_long(self) -> int: ...
    def as_signed_long(self) -> int: ...
    def as_string(self) -> str: ...
    def as_binary_string(self) -> bytes: ...

def is_bv(a: AstRef) -> bool: ...
def is_bv_value(a: AstRef) -> bool: ...
def BV2Int(a: BitVecRef, is_signed: bool = ...) -> ArithRef: ...
def Int2BV(a: asArithRef, num_bits: int) -> BitVecRef: ...
def BitVecSort(sz: int, ctx: Optional[Context] = ...) -> BitVecSortRef: ...
def BitVecVal(
    val: asArithRef, bv: int | BitVecSortRef, ctx: Optional[Context] = ...
) -> BitVecNumRef: ...
def BitVec(
    name: str, bv: int | BitVecSortRef, ctx: Optional[Context] = ...
) -> BitVecRef: ...
def BitVecs(
    names: str | typing.Iterable[str],
    bv: int | BitVecSortRef,
    ctx: Optional[Context] = ...,
) -> list[BitVecRef]: ...

# TODO
def Concat(*args): ...
def Extract(high, low, a): ...
def ULE(a, b): ...
def ULT(a, b): ...
def UGE(a, b): ...
def UGT(a, b): ...
def UDiv(a, b): ...
def URem(a, b): ...
def SRem(a, b): ...
def LShR(a, b): ...
def RotateLeft(a, b): ...
def RotateRight(a, b): ...
def SignExt(n, a): ...
def ZeroExt(n, a): ...
def RepeatBitVec(n, a): ...
def BVRedAnd(a): ...
def BVRedOr(a): ...
def BVAddNoOverflow(a, b, signed): ...
def BVAddNoUnderflow(a, b): ...
def BVSubNoOverflow(a, b): ...
def BVSubNoUnderflow(a, b, signed): ...
def BVSDivNoOverflow(a, b): ...
def BVSNegNoOverflow(a): ...
def BVMulNoOverflow(a, b, signed): ...
def BVMulNoUnderflow(a, b): ...

class ArraySortRef(SortRef):
    def domain(self) -> SortRef: ...
    def range(self) -> SortRef: ...

class ArrayRef(ExprRef):
    def sort(self) -> ArraySortRef: ...
    def domain(self) -> SortRef: ...
    def range(self) -> SortRef: ...
    def __getitem__(self, arg: asExprRef) -> ExprRef: ...
    def default(self) -> ExprRef: ...

@typing.overload
def is_array_sort(a: ArraySortRef) -> typing.Literal[True]: ...
@typing.overload
def is_array_sort(a: Any) -> bool: ...
@typing.overload
def is_array(a: ArrayRef) -> typing.Literal[True]: ...
@typing.overload
def is_array(a: Any) -> bool: ...
def is_const_array(a: Any) -> bool: ...
def is_K(a: Any) -> bool: ...
def is_map(a: Any) -> bool: ...
def is_default(a: Any) -> bool: ...
def get_map_func(a: ArrayRef) -> FuncDeclRef: ...
def ArraySort(*sig: SortRef) -> ArraySortRef: ...
def Array(name: str, dom: SortRef, rng: SortRef) -> ArrayRef: ...
def Update(a: ArrayRef, i: asExprRef, v: asExprRef) -> ExprRef: ...
def Default(a: ArrayRef) -> ExprRef: ...
def Store(a: ArrayRef, i: ExprRef, v: ExprRef) -> ArrayRef: ...
def Select(a: ArrayRef, i: ExprRef) -> ExprRef: ...
def Map(f: FuncDeclRef, *args: ArrayRef) -> ArrayRef: ...
def K(dom: SortRef, v: ExprRef) -> ArrayRef: ...
def Ext(a: ArraySortRef, b: ArrayRef) -> ExprRef: ...
def SetHasSize(a: ArrayRef, k: asExprRef) -> ExprRef: ...
def is_select(a: ExprRef) -> bool: ...
def is_store(a: ExprRef) -> bool: ...
def SetSort(s: SortRef) -> ArrayRef: ...
def EmptySet(s: SortRef) -> ArrayRef: ...
def FullSet(s: SortRef) -> ArrayRef: ...
def SetUnion(*args: ArrayRef) -> ArrayRef: ...
def SetIntersect(*args: ArrayRef) -> ArrayRef: ...
def SetAdd(s: ArrayRef, e: asExprRef) -> ArrayRef: ...
def SetDel(s: ArrayRef, e: asExprRef) -> ArrayRef: ...
def SetComplement(s: ArrayRef) -> ArrayRef: ...
def SetDifference(a: ArrayRef, b: ArrayRef) -> ArrayRef: ...
def IsMember(e: asExprRef, s: ArrayRef) -> BoolRef: ...
def IsSubset(a: ArrayRef, b: ArrayRef) -> BoolRef: ...

class Datatype:
    ctx: Context
    name: str
    constructors: list[tuple[str, str, tuple[Any]]]
    def __init__(self, name: str, ctx: Optional[Context] = ...) -> None: ...
    def __deepcopy__(self, memo: dict = ...) -> Datatype: ...
    def declare_core(
        self, name: str, rec_name: str, *args: tuple[str, Datatype | SortRef]
    ) -> None: ...
    def declare(self, name: str, *args: tuple[str, Datatype | SortRef]) -> None: ...
    def create(self) -> DatatypeSortRef: ...

class ScopedConstructor:
    c: Any
    ctx: Context
    def __init__(self, c, ctx: Context) -> None: ...
    def __del__(self) -> None: ...

class ScopedConstructorList:
    c: Any
    ctx: Context
    def __init__(self, c, ctx: Context) -> None: ...
    def __del__(self) -> None: ...

def CreateDatatypes(*ds: Datatype) -> tuple[DatatypeSortRef]: ...

class DatatypeSortRef(SortRef):
    def num_constructors(self) -> int: ...
    def constructor(self, idx: int) -> FuncDeclRef: ...
    def recognizer(self, idx: int) -> FuncDeclRef: ...
    def accessor(self, i: int, j: int) -> FuncDeclRef: ...

class DatatypeRef(ExprRef):
    def sort(self) -> DatatypeSortRef: ...

def TupleSort(
    name: str, sorts: typing.Sequence[SortRef | Datatype], ctx: Optional[Context] = ...
) -> tuple[DatatypeSortRef, Any, list[Any]]: ...
def DisjointSum(
    name: str, sorts: typing.Sequence[SortRef | Datatype], ctx: Optional[Context] = ...
) -> tuple[DatatypeSortRef, list[Any]]: ...
def EnumSort(
    name: str, values: typing.Sequence[str], ctx: Optional[Context] = ...
) -> tuple[DatatypeSortRef, list[Any]]: ...

class ParamsRef:
    ctx: Context
    params: Any
    def __init__(
        self, ctx: Optional[Context] = ..., params: Any | None = ...
    ) -> None: ...
    def __deepcopy__(self, memo=...) -> ParamsRef: ...
    def __del__(self) -> None: ...
    def set(self, name: str, val: int | str | float | bool) -> None: ...
    def validate(self, ds: ParamDescrsRef) -> None: ...

def args2params(
    arguments: list[int | str | float | bool],
    keywords: dict[str, int | str | float | bool],
    ctx: Optional[Context] = ...,
) -> ParamsRef: ...

class ParamDescrsRef:
    ctx: Context
    descr: ParamDescrs
    def __init__(self, descr: ParamDescrs, ctx: Optional[Context] = ...) -> None: ...
    def __deepcopy__(self, memo: dict=...) -> ParamDescrsRef: ...
    def __del__(self) -> None: ...
    def size(self) -> int: ...
    def __len__(self) -> int: ...
    def get_name(self, i: int) -> str: ...
    def get_kind(self, n: str) -> int: ...
    def get_documentation(self, n: str) -> str: ...
    @typing.overload
    def __getitem__(self, arg: int) -> str: ...
    @typing.overload
    def __getitem__(self, arg: str) -> int: ...


# TODO
class Goal(Z3PPObject):
    ctx: Context
    goal: Any
    def __init__(
        self,
        models: bool = ...,
        unsat_cores: bool = ...,
        proofs: bool = ...,
        ctx: Optional[Context] = ...,
        goal: Any | None = ...,
    ) -> None: ...
    def __del__(self) -> None: ...
    def depth(self): ...
    def inconsistent(self): ...
    def prec(self): ...
    def precision(self): ...
    def size(self): ...
    def __len__(self): ...
    def get(self, i): ...
    def __getitem__(self, arg): ...
    def assert_exprs(self, *args) -> None: ...
    def append(self, *args) -> None: ...
    def insert(self, *args) -> None: ...
    def add(self, *args) -> None: ...
    def convert_model(self, model): ...
    def sexpr(self): ...
    def dimacs(self, include_names: bool = ...): ...
    def translate(self, target): ...
    def __copy__(self): ...
    def __deepcopy__(self, memo=...): ...
    def simplify(self, *arguments, **keywords): ...
    def as_expr(self): ...

class AstVector(Z3PPObject):
    vector: Any
    ctx: Any
    def __init__(self, v: Any | None = ..., ctx: Optional[Context] = ...) -> None: ...
    def __del__(self) -> None: ...
    def __len__(self): ...
    def __getitem__(self, i): ...
    def __setitem__(self, i, v) -> None: ...
    def push(self, v) -> None: ...
    def resize(self, sz) -> None: ...
    def __contains__(self, item): ...
    def translate(self, other_ctx): ...
    def __copy__(self): ...
    def __deepcopy__(self, memo=...): ...
    def sexpr(self): ...

class AstMap:
    map: Any
    ctx: Any
    def __init__(self, m: Any | None = ..., ctx: Optional[Context] = ...) -> None: ...
    def __deepcopy__(self, memo=...): ...
    def __del__(self) -> None: ...
    def __len__(self): ...
    def __contains__(self, key): ...
    def __getitem__(self, key): ...
    def __setitem__(self, k, v) -> None: ...
    def erase(self, k) -> None: ...
    def reset(self) -> None: ...
    def keys(self): ...

class FuncEntry:
    entry: Any
    ctx: Any
    def __init__(self, entry, ctx) -> None: ...
    def __deepcopy__(self, memo=...): ...
    def __del__(self) -> None: ...
    def num_args(self): ...
    def arg_value(self, idx): ...
    def value(self): ...
    def as_list(self): ...

class FuncInterp(Z3PPObject):
    f: Any
    ctx: Any
    def __init__(self, f, ctx) -> None: ...
    def __del__(self) -> None: ...
    def else_value(self): ...
    def num_entries(self): ...
    def arity(self): ...
    def entry(self, idx): ...
    def translate(self, other_ctx): ...
    def __copy__(self): ...
    def __deepcopy__(self, memo=...): ...
    def as_list(self): ...

class ModelRef(Z3PPObject):
    model: Any
    ctx: Any
    def __init__(self, m, ctx) -> None: ...
    def __del__(self) -> None: ...
    def sexpr(self): ...
    def eval(self, t, model_completion: bool = ...): ...
    def evaluate(self, t, model_completion: bool = ...): ...
    def __len__(self): ...
    def get_interp(self, decl): ...
    def num_sorts(self): ...
    def get_sort(self, idx): ...
    def sorts(self): ...
    def get_universe(self, s): ...
    def __getitem__(self, idx): ...
    def decls(self): ...
    def translate(self, target): ...
    def __copy__(self): ...
    def __deepcopy__(self, memo=...): ...

def Model(ctx: Optional[Context] = ...): ...
def is_as_array(n): ...
def get_as_array_func(n): ...

class Statistics:
    stats: Any
    ctx: Any
    def __init__(self, stats, ctx) -> None: ...
    def __deepcopy__(self, memo=...): ...
    def __del__(self) -> None: ...
    def __len__(self): ...
    def __getitem__(self, idx): ...
    def keys(self): ...
    def get_key_value(self, key): ...
    def __getattr__(self, name): ...

class CheckSatResult:
    r: Any
    def __init__(self, r) -> None: ...
    def __deepcopy__(self, memo=...): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...

sat: Any
unsat: Any
unknown: Any

class Solver(Z3PPObject):
    ctx: Any
    backtrack_level: int
    solver: Any
    def __init__(
        self,
        solver: Any | None = ...,
        ctx: Optional[Context] = ...,
        logFile: Any | None = ...,
    ) -> None: ...
    def __del__(self) -> None: ...
    def set(self, *args, **keys) -> None: ...
    def push(self) -> None: ...
    def pop(self, num: int = ...) -> None: ...
    def num_scopes(self): ...
    def reset(self) -> None: ...
    def assert_exprs(self, *args) -> None: ...
    def add(self, *args) -> None: ...
    def __iadd__(self, fml): ...
    def append(self, *args) -> None: ...
    def insert(self, *args) -> None: ...
    def assert_and_track(self, a, p) -> None: ...
    def check(self, *assumptions): ...
    def model(self): ...
    def import_model_converter(self, other) -> None: ...
    def unsat_core(self): ...
    def consequences(self, assumptions, variables): ...
    def from_file(self, filename) -> None: ...
    def from_string(self, s) -> None: ...
    cube_vs: Any
    def cube(self, vars: Any | None = ...) -> typing.Iterator[Any]: ...
    def cube_vars(self): ...
    def proof(self): ...
    def assertions(self): ...
    def units(self): ...
    def non_units(self): ...
    def trail_levels(self): ...
    def trail(self): ...
    def statistics(self): ...
    def reason_unknown(self): ...
    def help(self) -> None: ...
    def param_descrs(self): ...
    def translate(self, target): ...
    def __copy__(self): ...
    def __deepcopy__(self, memo=...): ...
    def sexpr(self): ...
    def dimacs(self, include_names: bool = ...): ...
    def to_smt2(self): ...

def SolverFor(logic, ctx: Optional[Context] = ..., logFile: Any | None = ...): ...
def SimpleSolver(ctx: Optional[Context] = ..., logFile: Any | None = ...): ...

class Fixedpoint(Z3PPObject):
    ctx: Any
    fixedpoint: Any
    vars: Any
    def __init__(
        self, fixedpoint: Any | None = ..., ctx: Optional[Context] = ...
    ) -> None: ...
    def __deepcopy__(self, memo=...): ...
    def __del__(self) -> None: ...
    def set(self, *args, **keys) -> None: ...
    def help(self) -> None: ...
    def param_descrs(self): ...
    def assert_exprs(self, *args) -> None: ...
    def add(self, *args) -> None: ...
    def __iadd__(self, fml): ...
    def append(self, *args) -> None: ...
    def insert(self, *args) -> None: ...
    def add_rule(
        self, head, body: Any | None = ..., name: Any | None = ...
    ) -> None: ...
    def rule(self, head, body: Any | None = ..., name: Any | None = ...) -> None: ...
    def fact(self, head, name: Any | None = ...) -> None: ...
    def query(self, *query): ...
    def query_from_lvl(self, lvl, *query): ...
    def update_rule(self, head, body, name) -> None: ...
    def get_answer(self): ...
    def get_ground_sat_answer(self): ...
    def get_rules_along_trace(self): ...
    def get_rule_names_along_trace(self): ...
    def get_num_levels(self, predicate): ...
    def get_cover_delta(self, level, predicate): ...
    def add_cover(self, level, predicate, property) -> None: ...
    def register_relation(self, *relations) -> None: ...
    def set_predicate_representation(self, f, *representations) -> None: ...
    def parse_string(self, s): ...
    def parse_file(self, f): ...
    def get_rules(self): ...
    def get_assertions(self): ...
    def sexpr(self): ...
    def to_string(self, queries): ...
    def statistics(self): ...
    def reason_unknown(self): ...
    def declare_var(self, *vars) -> None: ...
    def abstract(self, fml, is_forall: bool = ...): ...

class FiniteDomainSortRef(SortRef):
    def size(self): ...

def FiniteDomainSort(name, sz, ctx: Optional[Context] = ...): ...
def is_finite_domain_sort(s) -> bool: ...

class FiniteDomainRef(ExprRef):
    def sort(self): ...
    def as_string(self): ...

def is_finite_domain(a) -> bool: ...

class FiniteDomainNumRef(FiniteDomainRef):
    def as_long(self) -> int: ...
    def as_string(self) -> str: ...

def FiniteDomainVal(val, sort, ctx: Optional[Context] = ...): ...
def is_finite_domain_value(a): ...

class OptimizeObjective:
    def __init__(self, opt, value, is_max) -> None: ...
    def lower(self): ...
    def upper(self): ...
    def lower_values(self): ...
    def upper_values(self): ...
    def value(self): ...

class Optimize(Z3PPObject):
    ctx: Any
    optimize: Any
    def __init__(self, ctx: Optional[Context] = ...) -> None: ...
    def __deepcopy__(self, memo=...): ...
    def __del__(self) -> None: ...
    def set(self, *args, **keys) -> None: ...
    def help(self) -> None: ...
    def param_descrs(self): ...
    def assert_exprs(self, *args) -> None: ...
    def add(self, *args) -> None: ...
    def __iadd__(self, fml): ...
    def assert_and_track(self, a, p) -> None: ...
    def add_soft(self, arg, weight: str = ..., id: Any | None = ...): ...
    def maximize(self, arg): ...
    def minimize(self, arg): ...
    def push(self) -> None: ...
    def pop(self) -> None: ...
    def check(self, *assumptions): ...
    def reason_unknown(self): ...
    def model(self): ...
    def unsat_core(self): ...
    def lower(self, obj): ...
    def upper(self, obj): ...
    def lower_values(self, obj): ...
    def upper_values(self, obj): ...
    def from_file(self, filename) -> None: ...
    def from_string(self, s) -> None: ...
    def assertions(self): ...
    def objectives(self): ...
    def sexpr(self): ...
    def statistics(self): ...
    def set_on_model(self, on_model) -> None: ...

class ApplyResult(Z3PPObject):
    result: Any
    ctx: Any
    def __init__(self, result, ctx) -> None: ...
    def __deepcopy__(self, memo=...): ...
    def __del__(self) -> None: ...
    def __len__(self): ...
    def __getitem__(self, idx): ...
    def sexpr(self): ...
    def as_expr(self): ...

class Tactic:
    ctx: Any
    tactic: Any
    def __init__(self, tactic, ctx: Optional[Context] = ...) -> None: ...
    def __deepcopy__(self, memo=...): ...
    def __del__(self) -> None: ...
    def solver(self, logFile: Any | None = ...): ...
    def apply(self, goal, *arguments, **keywords): ...
    def __call__(self, goal, *arguments, **keywords): ...
    def help(self) -> None: ...
    def param_descrs(self): ...

def AndThen(*ts, **ks): ...
def Then(*ts, **ks): ...
def OrElse(*ts, **ks): ...
def ParOr(*ts, **ks): ...
def ParThen(t1, t2, ctx: Optional[Context] = ...): ...
def ParAndThen(t1, t2, ctx: Optional[Context] = ...): ...
def With(t, *args, **keys): ...
def WithParams(t, p): ...
def Repeat(t, max: int = ..., ctx: Optional[Context] = ...): ...
def TryFor(t, ms, ctx: Optional[Context] = ...): ...
def tactics(ctx: Optional[Context] = ...): ...
def tactic_description(name, ctx: Optional[Context] = ...): ...
def describe_tactics() -> None: ...

class Probe:
    ctx: Any
    probe: Any
    def __init__(self, probe, ctx: Optional[Context] = ...) -> None: ...
    def __deepcopy__(self, memo=...): ...
    def __del__(self) -> None: ...
    def __lt__(self, other): ...
    def __gt__(self, other): ...
    def __le__(self, other): ...
    def __ge__(self, other): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __call__(self, goal): ...

def is_probe(p): ...
def probes(ctx: Optional[Context] = ...): ...
def probe_description(name, ctx: Optional[Context] = ...): ...
def describe_probes() -> None: ...
def FailIf(p, ctx: Optional[Context] = ...): ...
def When(p, t, ctx: Optional[Context] = ...): ...
def Cond(p, t1, t2, ctx: Optional[Context] = ...): ...
def simplify(a, *arguments, **keywords): ...
def help_simplify() -> None: ...
def simplify_param_descrs(): ...
def substitute(t, *m): ...
def substitute_vars(t, *m): ...
def Sum(*args): ...
def Product(*args): ...
def AtMost(*args): ...
def AtLeast(*args): ...
def PbLe(args, k): ...
def PbGe(args, k): ...
def PbEq(args, k, ctx: Optional[Context] = ...): ...
def solve(*args, **keywords) -> None: ...
def solve_using(s, *args, **keywords) -> None: ...
def prove(claim, show: bool = ..., **keywords) -> None: ...
def parse_smt2_string(s, sorts=..., decls=..., ctx: Optional[Context] = ...): ...
def parse_smt2_file(f, sorts=..., decls=..., ctx: Optional[Context] = ...): ...
def get_default_rounding_mode(ctx: Optional[Context] = ...): ...
def set_default_rounding_mode(rm, ctx: Optional[Context] = ...) -> None: ...
def get_default_fp_sort(ctx: Optional[Context] = ...): ...
def set_default_fp_sort(ebits, sbits, ctx: Optional[Context] = ...) -> None: ...

class FPSortRef(SortRef):
    def ebits(self): ...
    def sbits(self): ...
    def cast(self, val): ...

def Float16(ctx: Optional[Context] = ...): ...
def FloatHalf(ctx: Optional[Context] = ...): ...
def Float32(ctx: Optional[Context] = ...): ...
def FloatSingle(ctx: Optional[Context] = ...): ...
def Float64(ctx: Optional[Context] = ...): ...
def FloatDouble(ctx: Optional[Context] = ...): ...
def Float128(ctx: Optional[Context] = ...): ...
def FloatQuadruple(ctx: Optional[Context] = ...): ...

class FPRMSortRef(SortRef): ...

def is_fp_sort(s): ...
def is_fprm_sort(s): ...

class FPRef(ExprRef):
    def sort(self): ...
    def ebits(self): ...
    def sbits(self): ...
    def as_string(self): ...
    def __le__(self, other): ...
    def __lt__(self, other): ...
    def __ge__(self, other): ...
    def __gt__(self, other): ...
    def __add__(self, other): ...
    def __radd__(self, other): ...
    def __sub__(self, other): ...
    def __rsub__(self, other): ...
    def __mul__(self, other): ...
    def __rmul__(self, other): ...
    def __pos__(self): ...
    def __neg__(self): ...
    def __div__(self, other): ...
    def __rdiv__(self, other): ...
    def __truediv__(self, other): ...
    def __rtruediv__(self, other): ...
    def __mod__(self, other): ...
    def __rmod__(self, other): ...

class FPRMRef(ExprRef):
    def as_string(self): ...

def RoundNearestTiesToEven(ctx: Optional[Context] = ...): ...
def RNE(ctx: Optional[Context] = ...): ...
def RoundNearestTiesToAway(ctx: Optional[Context] = ...): ...
def RNA(ctx: Optional[Context] = ...): ...
def RoundTowardPositive(ctx: Optional[Context] = ...): ...
def RTP(ctx: Optional[Context] = ...): ...
def RoundTowardNegative(ctx: Optional[Context] = ...): ...
def RTN(ctx: Optional[Context] = ...): ...
def RoundTowardZero(ctx: Optional[Context] = ...): ...
def RTZ(ctx: Optional[Context] = ...): ...
def is_fprm(a): ...
def is_fprm_value(a): ...

class FPNumRef(FPRef):
    def sign(self): ...
    def sign_as_bv(self): ...
    def significand(self): ...
    def significand_as_long(self): ...
    def significand_as_bv(self): ...
    def exponent(self, biased: bool = ...): ...
    def exponent_as_long(self, biased: bool = ...): ...
    def exponent_as_bv(self, biased: bool = ...): ...
    def isNaN(self): ...
    def isInf(self): ...
    def isZero(self): ...
    def isNormal(self): ...
    def isSubnormal(self): ...
    def isPositive(self): ...
    def isNegative(self): ...
    def as_string(self): ...

def is_fp(a): ...
def is_fp_value(a): ...
def FPSort(ebits, sbits, ctx: Optional[Context] = ...): ...
def fpNaN(s): ...
def fpPlusInfinity(s): ...
def fpMinusInfinity(s): ...
def fpInfinity(s, negative): ...
def fpPlusZero(s): ...
def fpMinusZero(s): ...
def fpZero(s, negative): ...
def FPVal(
    sig, exp: Any | None = ..., fps: Any | None = ..., ctx: Optional[Context] = ...
): ...
def FP(name, fpsort, ctx: Optional[Context] = ...): ...
def FPs(names, fpsort, ctx: Optional[Context] = ...): ...
def fpAbs(a, ctx: Optional[Context] = ...): ...
def fpNeg(a, ctx: Optional[Context] = ...): ...
def fpAdd(rm, a, b, ctx: Optional[Context] = ...): ...
def fpSub(rm, a, b, ctx: Optional[Context] = ...): ...
def fpMul(rm, a, b, ctx: Optional[Context] = ...): ...
def fpDiv(rm, a, b, ctx: Optional[Context] = ...): ...
def fpRem(a, b, ctx: Optional[Context] = ...): ...
def fpMin(a, b, ctx: Optional[Context] = ...): ...
def fpMax(a, b, ctx: Optional[Context] = ...): ...
def fpFMA(rm, a, b, c, ctx: Optional[Context] = ...): ...
def fpSqrt(rm, a, ctx: Optional[Context] = ...): ...
def fpRoundToIntegral(rm, a, ctx: Optional[Context] = ...): ...
def fpIsNaN(a, ctx: Optional[Context] = ...): ...
def fpIsInf(a, ctx: Optional[Context] = ...): ...
def fpIsZero(a, ctx: Optional[Context] = ...): ...
def fpIsNormal(a, ctx: Optional[Context] = ...): ...
def fpIsSubnormal(a, ctx: Optional[Context] = ...): ...
def fpIsNegative(a, ctx: Optional[Context] = ...): ...
def fpIsPositive(a, ctx: Optional[Context] = ...): ...
def fpLT(a, b, ctx: Optional[Context] = ...): ...
def fpLEQ(a, b, ctx: Optional[Context] = ...): ...
def fpGT(a, b, ctx: Optional[Context] = ...): ...
def fpGEQ(a, b, ctx: Optional[Context] = ...): ...
def fpEQ(a, b, ctx: Optional[Context] = ...): ...
def fpNEQ(a, b, ctx: Optional[Context] = ...): ...
def fpFP(sgn, exp, sig, ctx: Optional[Context] = ...): ...
def fpToFP(
    a1, a2: Any | None = ..., a3: Any | None = ..., ctx: Optional[Context] = ...
): ...
def fpBVToFP(v, sort, ctx: Optional[Context] = ...): ...
def fpFPToFP(rm, v, sort, ctx: Optional[Context] = ...): ...
def fpRealToFP(rm, v, sort, ctx: Optional[Context] = ...): ...
def fpSignedToFP(rm, v, sort, ctx: Optional[Context] = ...): ...
def fpUnsignedToFP(rm, v, sort, ctx: Optional[Context] = ...): ...
def fpToFPUnsigned(rm, x, s, ctx: Optional[Context] = ...): ...
def fpToSBV(rm, x, s, ctx: Optional[Context] = ...): ...
def fpToUBV(rm, x, s, ctx: Optional[Context] = ...): ...
def fpToReal(x, ctx: Optional[Context] = ...): ...
def fpToIEEEBV(x, ctx: Optional[Context] = ...): ...

class SeqSortRef(SortRef):
    def is_string(self): ...
    def basis(self): ...

def StringSort(ctx: Optional[Context] = ...): ...
def SeqSort(s): ...

class SeqRef(ExprRef):
    def sort(self): ...
    def __add__(self, other): ...
    def __radd__(self, other): ...
    def __getitem__(self, i): ...
    def at(self, i): ...
    def is_string(self): ...
    def is_string_value(self): ...
    def as_string(self): ...
    def __le__(self, other): ...
    def __lt__(self, other): ...
    def __ge__(self, other): ...
    def __gt__(self, other): ...

def is_seq(a): ...
def is_string(a): ...
def is_string_value(a): ...
def StringVal(s, ctx: Optional[Context] = ...): ...
def String(name, ctx: Optional[Context] = ...): ...
def Strings(names, ctx: Optional[Context] = ...): ...
def SubString(s, offset, length): ...
def SubSeq(s, offset, length): ...
def Empty(s): ...
def Full(s): ...
def Unit(a): ...
def PrefixOf(a, b): ...
def SuffixOf(a, b): ...
def Contains(a, b): ...
def Replace(s, src, dst): ...
def IndexOf(s, substr, offset: Any | None = ...): ...
def LastIndexOf(s, substr): ...
def Length(s): ...
def StrToInt(s): ...
def IntToStr(s): ...
def Re(s, ctx: Optional[Context] = ...): ...

class ReSortRef(SortRef):
    def basis(self): ...

def ReSort(s): ...

class ReRef(ExprRef):
    def __add__(self, other): ...

def is_re(s): ...
def InRe(s, re): ...
def Union(*args): ...
def Intersect(*args): ...
def Plus(re): ...
def Option(re): ...
def Complement(re): ...
def Star(re): ...
def Loop(re, lo, hi: int = ...): ...
def Range(lo, hi, ctx: Optional[Context] = ...): ...
def PartialOrder(a, index): ...
def LinearOrder(a, index): ...
def TreeOrder(a, index): ...
def PiecewiseLinearOrder(a, index): ...
def TransitiveClosure(f): ...

class PropClosures:
    bases: Any
    lock: Any
    def __init__(self) -> None: ...
    def set_threaded() -> None: ...
    def get(self, ctx): ...
    def set(self, ctx, r) -> None: ...
    def insert(self, r): ...

def ensure_prop_closures() -> None: ...
def user_prop_push(ctx) -> None: ...
def user_prop_pop(ctx, num_scopes) -> None: ...
def user_prop_fresh(id, ctx): ...
def user_prop_fixed(ctx, cb, id, value) -> None: ...
def user_prop_final(ctx, cb) -> None: ...
def user_prop_eq(ctx, cb, x, y) -> None: ...
def user_prop_diseq(ctx, cb, x, y) -> None: ...

class UserPropagateBase:
    solver: Any
    cb: Any
    id: Any
    fixed: Any
    final: Any
    eq: Any
    diseq: Any
    def __init__(self, s, ctx: Optional[Context] = ...) -> None: ...
    def __del__(self) -> None: ...
    def ctx(self): ...
    def ctx_ref(self): ...
    def add_fixed(self, fixed) -> None: ...
    def add_final(self, final) -> None: ...
    def add_eq(self, eq) -> None: ...
    def add_diseq(self, diseq) -> None: ...
    def push(self) -> None: ...
    def pop(self, num_scopes) -> None: ...
    def fresh(self) -> None: ...
    def add(self, e): ...
    def propagate(self, e, ids, eqs=...) -> None: ...
    def conflict(self, ids) -> None: ...
